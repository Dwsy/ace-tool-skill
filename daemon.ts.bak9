import { spawn } from "bun";

// é…ç½®
interface Config {
  apiKey: string;
  baseUrl: string;
  port: number;
  heartbeatTimeoutMinutes: number;
  rpcTimeoutSeconds: number;
}

/**
 * é…ç½®ç®¡ç†å™¨
 */
class ConfigManager {
  private _config: Config;

  constructor() {
    const apiKey = process.env.ACE_API_KEY;
    const baseUrl = process.env.ACE_BASE_URL;
    const port = parseInt(process.env.ACE_PORT || "4231");
    const heartbeatTimeoutMinutes = parseInt(process.env.ACE_HEARTBEAT_TIMEOUT_MINUTES || "120"); // é»˜è®¤ 120 åˆ†é’Ÿï¼ˆ2 å°æ—¶ï¼‰
    const rpcTimeoutSeconds = parseInt(process.env.ACE_RPC_TIMEOUT_SECONDS || "300"); // é»˜è®¤ 5 åˆ†é’Ÿï¼ˆ300 ç§’ï¼‰

    if (!apiKey || !baseUrl) {
      throw new Error("Missing configuration in .env");
    }

    this._config = {
      apiKey,
      baseUrl,
      port,
      heartbeatTimeoutMinutes,
      rpcTimeoutSeconds
    };
  }

  get config(): Config {
    return this._config;
  }

  get heartbeatTimeoutMs(): number {
    return this._config.heartbeatTimeoutMinutes * 60 * 1000;
  }

  get rpcTimeoutMs(): number {
    return this._config.rpcTimeoutSeconds * 1000;
  }
}

/**
 * RPC å®¢æˆ·ç«¯
 */
class RpcClient {
  private process: any;
  private pendingRequests: Map<string, {
    resolve: (value: any) => void;
    reject: (error: Error) => void;
  }>;
  private messageBuffer = "";
  private rpcTimeoutMs: number;

  constructor(private configManager: ConfigManager) {
    this.process = null;
    this.pendingRequests = new Map();
    this.messageBuffer = "";
    this.rpcTimeoutMs = configManager._config.rpcTimeoutSeconds * 1000;
  }

  /**
   * å¯åŠ¨ ace-tool è¿›ç¨‹
   */
  start(): void {
    console.log("Starting ace-tool process...");

    this.process = spawn({
      cmd: ["ace-tool", "--base-url", this.configManager._config.baseUrl, "--token", this.configManager._config.apiKey, "--enable-log"],
      stdin: "pipe",
      stdout: "pipe",
      stderr: "inherit",
    });

    console.log(`Ace-tool PID: ${this.process.pid}`);

    // ç›‘å¬è¿›ç¨‹é€€å‡º
    this.process.exited.then((code: number) => {
      console.log(`Ace-tool process exited with code: ${code}`);
      this.process = null;
    }).catch((err: Error) => {
      console.error('Ace-tool error:', err);
    });

    // å¯åŠ¨è¾“å‡ºè¯»å–
    this.startOutputReader();
  }

  /**
   * å¯åŠ¨è¾“å‡ºè¯»å–å™¨
   */
  private startOutputReader(): void {
    const reader = this.process.stdout.getReader();
    const decoder = new TextDecoder();

    const readLoop = async () => {
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          this.messageBuffer += chunk;

          const lines = this.messageBuffer.split("\n");
          this.messageBuffer = lines.pop() || "";

          for (const line of lines) {
            if (!line.trim()) continue;
            try {
              const msg = JSON.parse(line);
              if (msg.id && this.pendingRequests.has(msg.id)) {
                const { resolve, reject } = this.pendingRequests.get(msg.id);
                this.pendingRequests.delete(msg.id);
                if (msg.error) {
                  reject(msg.error);
                } else {
                  resolve(msg.result);
                }
              }
            } catch (e) {
              console.error("Failed to parse ace-tool output:", line);
            }
          }
        }
      } catch (error) {
        console.error("Output reader error:", error);
      }
    };

    readLoop().catch(console.error);
  }

  /**
   * å‘é€ JSON-RPC è¯·æ±‚
   */
  async sendRpc(method: string, params: any, id?: string): Promise<any> {
    const requestId = id || Math.floor(Math.random() * 1000000);
    const request = {
      jsonrpc: "2.0",
      id: requestId,
      method,
      params
    };

    this.process.stdin.write(new TextEncoder().encode(JSON.stringify(request) + "\n"));
    await this.process.stdin.flush();

    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        if (this.pendingRequests.has(requestId)) {
          this.pendingRequests.delete(requestId);
          reject(new Error(`Timeout calling ${method}`));
        }
      }, this.rpcTimeoutMs);

      this.pendingRequests.set(requestId, {
        resolve: (res) => { clearTimeout(timeout); resolve(res); },
        reject: (err) => { clearTimeout(timeout); reject(err); }
      });
    });
  }

  /**
   * å‘é€é€šçŸ¥ï¼ˆæ— å“åº”ï¼‰
   */
  async sendNotification(method: string, params: any): Promise<void> {
    const notification = {
      jsonrpc: "2.0",
      method,
      params
    };

    this.process.stdin.write(new TextEncoder().encode(JSON.stringify(notification) + "\n"));
    await this.process.stdin.flush();
  }

  /**
   * åˆå§‹åŒ– MCP æ¡æ‰‹
   */
  async initialize(): Promise<void> {
    try {
      console.log("Initializing MCP handshake...");
      await this.sendRpc("initialize", {
        protocolVersion: "2024-11-05",
        capabilities: {},
        clientInfo: { name: "pi-ace-bridge", version: "1.0.0" }
      });

      await this.sendNotification("notifications/initialized", {});
      console.log("MCP Initialized successfully.");
    } catch (e) {
      console.error("MCP Initialization failed:", e);
    }
  }

  /**
   * æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿è¡Œ
   */
  isRunning(): boolean {
    return this.process !== null && this.process.pid !== undefined;
  }

  /**
   * å…³é—­è¿›ç¨‹
   */
  async shutdown(): Promise<void> {
    if (!this.process) {
      console.log("Ace-tool process already stopped");
      return;
    }

    console.log("Shutting down ace-tool process...");

    // å°è¯•ä¼˜é›…å…³é—­
    this.process.kill('SIGTERM');
    await new Promise(resolve => setTimeout(resolve, 5000));

    // å¦‚æœè¿˜åœ¨è¿è¡Œï¼Œå¼ºåˆ¶æ€æ­»
    if (this.process && this.process.pid) {
      console.log("Force killing ace-tool process...");
      this.process.kill('SIGKILL');
    }

    this.process = null;
  }
}

/**
 * å¿ƒè·³ç®¡ç†å™¨
 */
class HeartbeatManager {
  private timer: NodeJS.Timeout | null = null;
  private lastActivityTime: number;
  private timeoutMs: number;
  private onTimeout: () => void;

  constructor(timeoutMinutes: number, onTimeout: () => void) {
    this.timeoutMs = timeoutMinutes * 60 * 1000;
    this.lastActivityTime = Date.now();
    this.onTimeout = onTimeout;
  }

  /**
   * æ›´æ–°æ´»åŠ¨æ—¶é—´
   */
  updateActivity(): void {
    this.lastActivityTime = Date.now();
  }

  /**
   * å¯åŠ¨å¿ƒè·³æ£€æµ‹
   */
  start(): void {
    if (this.timeoutMs <= 0) {
      console.log("Heartbeat disabled (timeout = 0)");
      return;
    }

    console.log(`Starting heartbeat timer (${this.timeoutMs / 60000} minutes timeout)`);

    this.timer = setInterval(() => {
      const elapsed = Date.now() - this.lastActivityTime;
      
      console.log(`[Heartbeat] Last activity: ${Math.floor(elapsed / 60000)} minutes ago`);

      if (elapsed >= this.timeoutMs) {
        console.log(`[Heartbeat] No activity for ${this.timeoutMs / 60000} minutes, triggering timeout...`);
        this.onTimeout();
      }
    }, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
  }

  /**
   * åœæ­¢å¿ƒè·³
   */
  stop(): void {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }

  /**
   * è·å–å‰©ä½™æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
   */
  getRemainingMinutes(): number {
    const elapsed = Date.now() - this.lastActivityTime;
    const remaining = this.timeoutMs - elapsed;
    return Math.ceil(remaining / 60000);
  }
}

/**
 * HTTP æœåŠ¡å™¨
 */
class HttpServer {
  private port: number;
  private rpcClient: RpcClient;
  private heartbeatManager: HeartbeatManager;
  private server: any;

  constructor(port: number, rpcClient: RpcClient, heartbeatManager: HeartbeatManager) {
    this.port = port;
    this.rpcClient = rpcClient;
    this.heartbeatManager = heartbeatManager;
    this.server = null;
  }

  /**
   * å¯åŠ¨ HTTP æœåŠ¡å™¨
   */
  start(): void {
    console.log(`Starting HTTP server on port ${this.port}`);

    this.server = Bun.serve({
      port: this.port,
      hostname: '0.0.0.0',
      fetch: async (req: Request) => this.handleRequest(req),
    });

    console.log(`HTTP server listening on port ${this.port}`);
  }

  /**
   * å¤„ç† HTTP è¯·æ±‚
   */
  async handleRequest(req: Request): Promise<Response> {
    const url = new URL(req.url);

    // Web UI é¡µé¢
    if (url.pathname === "/" || url.pathname === "/web") {
      return this.handleWebUI();
    }

    // å¥åº·æ£€æŸ¥
    if (url.pathname === "/health") {
      return this.handleHealthCheck();
    }

    // å·¥å…·è°ƒç”¨æ¥å£
    if (url.pathname === "/call" && req.method === "POST") {
      return this.handleToolCall(req);
    }

    // å…¶ä»–è¯·æ±‚è¿”å› 404
    return new Response("Not Found", { status: 404 });
  }

  /**
   * å¤„ç† Web UI é¡µé¢
   */
  private async handleWebUI(): Promise<Response> {
    try {
      const webUIPath = new URL(import.meta.url).pathname.replace('daemon.ts', 'webui.ts');
      const webUIContent = await Bun.file(webUIPath).text();
      const match = webUIContent.match(/const HTML_TEMPLATE = `([\s\S]+?)`;/);
      if (!match) return new Response('Web UI not found', { status: 404 });
      return new Response(match[1], { headers: { 'Content-Type': 'text/html; charset=utf-8' } });
    } catch (error) {
      console.error('Failed to load Web UI:', error);
      return new Response('Failed to load Web UI', { status: 500 });
    }
  }

  /**
   * å¤„ç†å¥åº·æ£€æŸ¥
   */
  private async handleHealthCheck(): Promise<Response> {
    const elapsed = Date.now() - this.heartbeatManager.lastActivityTime;
    const remaining = this.heartbeatManager.getRemainingMinutes();
    const heartbeatTimeout = this.heartbeatManager.timeoutMs / 60000;
    const rpcTimeout = this.rpcClient.rpcTimeoutMs / 1000;

    return new Response(JSON.stringify({
      status: this.rpcClient.isRunning() ? 'running' : 'stopped',
      uptime: Math.floor(elapsed / 1000), // ç§’
      lastActivity: new Date(this.heartbeatManager.lastActivityTime).toISOString(),
      remainingMinutes: remaining, // å‰©ä½™åˆ†é’Ÿ
      rpcTimeout: rpcTimeout,  // RPC è¶…æ—¶ï¼ˆç§’ï¼‰
      heartbeatTimeout: heartbeatTimeout  // å¿ƒè·³è¶…æ—¶ï¼ˆåˆ†é’Ÿï¼‰
    }), {
      headers: { "Content-Type": "application/json; charset=utf-8" },
    });
  }

  /**
   * å¤„ç†å·¥å…·è°ƒç”¨
   */
  private async handleToolCall(req: Request): Promise<Response> {
    console.log("[HTTP] handleToolCall called");
    try {
      const body = await req.json();
      console.log("[HTTP] Request body:", JSON.stringify(body));
      const { method, params } = body;

      const result = await this.rpcClient.sendRpc(method, params);
      console.log("[HTTP] RPC result:", JSON.stringify(result));

      return new Response(JSON.stringify({ result }), {
        headers: { "Content-Type": "application/json; charset=utf-8" },
      });
    } catch (error) {
      return new Response(JSON.stringify({ error: (error as Error).message }), {
        status: 500,
        headers: { "Content-Type": "application/json; charset=utf-8" },
      });
    }
  }

  /**
   * åœæ­¢æœåŠ¡å™¨
   */
  async stop(): Promise<void> {
    if (this.server) {
      // Bun.serve æ²¡æœ‰ç›´æ¥çš„ stop æ–¹æ³•
      console.log("HTTP server stopped (process will exit when all connections close)");
      this.server = null;
    }
  }

  /**
   * å…³é—­æœåŠ¡å™¨
   */
  async shutdown(): Promise<void> {
    await this.stop();
  }
}

/**
 * Daemon Facadeï¼ˆå®ˆæŠ¤è¿›ç¨‹é—¨é¢ï¼‰
 * è´Ÿè´£ç®¡ç† ace-tool æœåŠ¡çš„ç”Ÿå‘½å‘¨æœŸ
 */
class DaemonFacade {
  private config: ConfigManager;
  private rpcClient: RpcClient;
  private heartbeatManager: HeartbeatManager;
  private httpServer: HttpServer;

  constructor(port?: number) {
    this.config = new ConfigManager();
    this.rpcClient = new RpcClient(this.config);
    this.heartbeatManager = new HeartbeatManager(
      this.config._config.heartbeatTimeoutMinutes,
      () => this.shutdown()
    );
    this.httpServer = new HttpServer(port || this.config._config.port, this.rpcClient, this.heartbeatManager);
  }

  /**
   * åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶
   */
  async initialize(): Promise<void> {
    console.log("Initializing Daemon Facade...");
    
    // 1. å¯åŠ¨ ace-tool
    this.rpcClient.start();
    
    // 2. åˆå§‹åŒ– MCP
    await this.rpcClient.initialize();
    
    // 3. å¯åŠ¨å¿ƒè·³
    this.heartbeatManager.start();
    
    // 4. å¯åŠ¨ HTTP æœåŠ¡å™¨
    this.httpServer.start();
    
    console.log("âœ… Daemon Facade initialized successfully");
  }

  /**
   * å…³é—­æ‰€æœ‰ç»„ä»¶
   */
  async shutdown(): Promise<void> {
    console.log("Shutting down Daemon Facade...");
    
    // 1. åœæ­¢å¿ƒè·³
    this.heartbeatManager.stop();
    
    // 2. å…³é—­ ace-tool
    await this.rpcClient.shutdown();
    
    // 3. å…³é—­ HTTP æœåŠ¡å™¨
    await this.httpServer.shutdown();
    
    console.log("âœ… Daemon Facade shutdown complete");
  }

  /**
   * è·å–çŠ¶æ€
   */
  getStatus() {
    return {
      aceTool: {
        running: this.rpcClient.isRunning(),
        pid: this.rpcClient.isRunning() ? this.rpcClient.process.pid : null
      },
      heartbeat: {
        running: this.heartbeatManager.timer !== null,
        timeout: this.config._config.heartbeatTimeoutMinutes,  // åˆ†é’Ÿ
        remaining: this.heartbeatManager.getRemainingMinutes(), // åˆ†é’Ÿ
        lastActivity: new Date(this.heartbeatManager.lastActivityTime).toISOString()
      },
      config: {
        heartbeatTimeout: this.config._config.heartbeatTimeoutMinutes,  // åˆ†é’Ÿ
        rpcTimeout: this.config._config.rpcTimeoutSeconds,  // ç§’
      },
      http: {
        running: this.httpServer.server !== null,
        port: this.config._config.port
      }
    };
  }
}

/**
 * ä¸»å…¥å£
 */
async function main() {
  const daemon = new DaemonFacade();

  try {
    await daemon.initialize();

    console.log("\nğŸ‰ ACE Tool Daemon is running!");
    console.log(`ğŸ“¡ Health: http://localhost:${daemon.config._config.port}/health`);
    console.log(`ğŸ” API: http://localhost:${daemon.config._config.port}/call`);
    console.log(`ğŸ’¡ Heartbeat: ${daemon.config._config.heartbeatTimeoutMinutes} åˆ†é’Ÿ`);
    console.log(`â±ï¸  RPC Timeout: ${daemon.config._config.rpcTimeoutSeconds} ç§’`);
    console.log(`ğŸŒï¸  Web UI: http://localhost:${daemon.config._config.port}/`);
    console.log(`\nPress Ctrl+C to stop`);

    // ä¼˜é›…å…³é—­
    process.on('SIGINT', async () => {
      console.log('\nğŸ›‘ï¸ Received SIGINT, shutting down...');
      await daemon.shutdown();
    });

    process.on('SIGTERM', async () => {
      console.log('\nğŸ›‘ï¸ Received SIGTERM, shutting down...');
      await daemon.shutdown();
    });

    // ä¿æŒè¿›ç¨‹è¿è¡Œ
    await new Promise(() => {}); // æ°¸ä¹…è¿è¡Œ

  } catch (error) {
    console.error('Failed to start daemon:', error);
    process.exit(1);
  }
}

// å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹
main();